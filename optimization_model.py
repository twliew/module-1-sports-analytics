"""
Optimization Module for Sports Analytics Dashboard
Integrates ML predictions with lineup optimization constraints
"""

import pandas as pd
from itertools import combinations
from typing import Dict, List, Tuple, Optional


class LineupOptimizer:
    """
    Optimizes team lineups based on player scores and constraints.
    Uses ML-predicted player scores from part1_DataAndML.ipynb
    """
    
    def __init__(self, player_scores_path: str = "player_scores.xlsx"):
        """
        Initialize optimizer with ML-predicted player scores.
        
        Args:
            player_scores_path: Path to player_scores.xlsx generated by part1
        """
        self.player_scores = pd.read_excel(player_scores_path)
        print(f"Loaded {len(self.player_scores)} players from ML model")
    
    def optimize_lineup(
        self,
        team_df: pd.DataFrame,
        availability: Dict[str, bool],
        fatigue: Dict[str, float],
        disability_cap: float,
        fatigue_weight: float = 2.0,
        lineup_size: int = 4,
    ) -> Dict:
        """
        Optimize team lineup using ML scores with constraints.
        
        Args:
            team_df: DataFrame with players (must have player_id, disability_score, value_score)
            availability: Dict mapping player_id -> is_available (bool)
            fatigue: Dict mapping player_id -> fatigue_level (0-100)
            disability_cap: Maximum total disability score for lineup
            fatigue_weight: Weight for fatigue penalty (higher = more penalty)
            lineup_size: Number of players to select (default: 4)
        
        Returns:
            Dict with keys:
                - lineup: List of selected player_ids
                - objective: Total optimization score
                - notes: Description of result
                - breakdown: List of player details in lineup
        """
        
        # Filter to available players
        available_df = team_df[
            team_df["player_id"].map(lambda x: availability.get(x, True))
        ].copy()
        
        if len(available_df) < lineup_size:
            return {
                "lineup": [],
                "objective": 0.0,
                "notes": f"Not enough available players. Need {lineup_size}, have {len(available_df)}.",
                "breakdown": []
            }
        
        # Calculate adjusted score = value_score - fatigue_penalty
        available_df["fatigue"] = available_df["player_id"].map(
            lambda x: fatigue.get(x, 0.0)
        )
        available_df["score_adjusted"] = (
            available_df["value_score"] 
            - fatigue_weight * (available_df["fatigue"] / 100.0)
        )
        
        # Build lookup for quick access
        df_idx = available_df.set_index("player_id")
        player_ids = available_df["player_id"].tolist()
        
        # Find best combination that respects disability_cap
        best_combo = None
        best_obj = -float('inf')
        best_disability_sum = 0
        
        for combo in combinations(player_ids, lineup_size):
            combo_list = list(combo)
            disability_sum = float(df_idx.loc[combo_list, "disability_score"].sum())
            
            # Check constraint
            if disability_sum <= disability_cap:
                obj = float(df_idx.loc[combo_list, "score_adjusted"].sum())
                if obj > best_obj:
                    best_obj = obj
                    best_combo = combo_list
                    best_disability_sum = disability_sum
        
        if not best_combo:
            return {
                "lineup": [],
                "objective": 0.0,
                "notes": f"No feasible lineup found under disability cap of {disability_cap}.",
                "breakdown": []
            }
        
        # Build breakdown for dashboard
        breakdown = []
        for pid in best_combo:
            player_row = df_idx.loc[pid]
            breakdown.append({
                "player_id": pid,
                "value_score": float(player_row["value_score"]),
                "fatigue": float(player_row["fatigue"]),
                "adjusted_score": float(player_row["score_adjusted"]),
                "disability_score": float(player_row["disability_score"])
            })
        
        return {
            "lineup": best_combo,
            "objective": best_obj,
            "disability_sum": best_disability_sum,
            "notes": f"Optimal lineup with disability score {best_disability_sum:.1f}/{disability_cap}",
            "breakdown": breakdown
        }


# For direct use in app.py
def create_optimizer(player_scores_path: str = "player_scores.xlsx") -> LineupOptimizer:
    """Helper to create optimizer instance"""
    try:
        return LineupOptimizer(player_scores_path)
    except FileNotFoundError:
        print(f"Warning: {player_scores_path} not found. Using placeholder optimizer.")
        return None
